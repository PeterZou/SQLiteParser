grammar SQLiteParserSimple;

options {
    language=Java;
    TokenLabelType=CommonToken;
    output=AST;
    ASTLabelType=CommonTree;
}

@lexer::namespace{SQLiteParser}
@parser::namespace{SQLiteParser}

/*
 * Parser Rules
 */

public
statement : create_table
    | EOF
    ;
	
create_table : CREATE TEMPORARY? TABLE (IF NOT EXISTS)? table_name '(' column_def (',' column_def)* ')' (table_constraint (',' table_constraint)?)?  (WITHOUT ROWID)? SEMICOLON;

column_def:  NAME type_name? column_constraint_def*;

type_name : WORD ('(' signed_number (',' signed_number)* ')') ?;

signed_number: ('+'|'-')? numeric_literal;

numeric_literal: ((DIGIT+  ('.' DIGIT*)?)| ('.' DIGIT+)) (('e'|'E') ('+'|'-')? DIGIT+)?;

table_name : qualified_name;

qualified_name : WORD ('.' WORD)?;

column_constraint_def : (CONSTRAINT WORD)? column_constraint;

column_constraint : NOT_NULL conflict_clause?
    {
        $return = {
            type => 'not_null',
        }
    }
    |
    PRIMARY_KEY sort_order? conflict_clause (AUTOINCREMENT)?
    {
        $return = {
            type        => 'primary_key',
            sort_order  => $item[2][0],
            on_conflict => $item[2][0],
        }
    }
    |
    UNIQUE conflict_clause
    {
        $return = {
            type        => 'unique',
            on_conflict => $item[2][0],
        }
    }
    |
    CHECK_C '(' expr ')'
    {
        $return = {
            type        => 'check',
            expression  => $item[3],
            on_conflict => $item[5][0],
        }
    }
    |
    DEFAULT VALUE
    {
        $return   = {
            type  => 'default',
            value => $item[2],
        }
    }
    |
	COLLATE collation_name
	|
    foreign_key_clause;


foreign_key_clause: REFERENCES  table_name parens_field_list? cascade_def?;

collation_name: WORD;


parens_field_list : '(' column_list ')';
column_list : WORD (',' WORD)*;

cascade_def: (( ON (foreign_on_delete | foreign_on_update))  | foreign_match)* foreign_deferrable?;

foreign_deferrable: NOT? DEFERRABLE ((INITIALLY DEFERRED)| (INITIALLY IMMEDIATE))?;
foreign_on_delete: DELETE (SET NULL|SET DEFAULT|CASCADE|RESTRICT|NO ACTION);
foreign_on_update: UPDATE (SET NULL|SET DEFAULT|CASCADE|RESTRICT|NO ACTION);
conflict_clause: (ON CONFLICT (ROLLBACK| ABORT|FAIL|IGNORE|REPLACE))?;



table_constraint: (prim_key_or_uniq | check | foreign_key_constraint);


prim_key_or_uniq: ((PRIMARY KEY) | UNIQUE) indexed_columns conflict_clause;

indexed_columns: '(' indexed_column (',' indexed_column)? ')';
indexed_column: WORD (COLLATE WORD)? sort_order?;

foreign_key_constraint: FOREIGN KEY parens_field_list foreign_key_clause;
foreign_match: MATCH WORD;
sort_order: ASC |DESC;
check: CHECK '(' expr ')';




//holy cow
expr: literal_value
	| bind_parameter
	| ((WORD '.')? WORD '.')? WORD
	| unary_operator expr
	| expr_starting_expr
	| expr binary_operator expr
	| function_expr
	| '(' expr ')'
	| CAST '(' expr AS type_name ')' //?
	| expr COLLATE NAME
	
	
	
	
	
	| (NOT? EXISTS)? '(' select_stmt ')'
	| CASE expr?  (WHEN expr THEN expr)+ (ELSE expr)? END
	| raise_function;


//* all exprs starting with expr!	
expr_starting_expr
	:	expr (expr_starting_with_not |expr_end_null | expr_end_is_not_expr); 


expr_end_null: ISNULL | NOTNULL| NOT NULL;
expr_end_is_not_expr: IS NOT? expr;
expr_starting_expr_with_not
	:	NOT? (expr_end_between|  expr_end_in | expr_end_match);



expr_end_match: (LIKE |GLOB| REGEXP | MATCH) expr (ESCAPE expr)?;
expr_end_in: IN 
	(table_name |
	 (
	 '(' (
			select_stmt | 
							(
								expr 
									(
										','expr
									)? 
							)
							)? ')'));
expr_end_between
	:	 BETWEEN expr AND expr;
	
	*/
	 
select_stmt: SELECT; // this is bad!!!
function_expr: function_name '('function_expr_params ')';
function_expr_params: ( '*'| (DISTINCT? expr (',' expr)*))?;

raise_function: RAISE '(' (IGNORE | ((ROLLBACK | ABORT | FAIL) ',' error_message)) ')';


bind_parameter: '?' | ('?' DIGIT+) | (':' WORD) | ('@' WORD) | ('$' WORD);
literal_value: numeric_literal
		| string_literal
		| blob_literal
		| NULL
		| CURRENT_TIME
		| CURRENT_DATE
		| CURRENT_TIMESTAMP;

string_literal:'\'' ANYCHAR? '\'';
blob_literal: ('x'|'X') string_literal;

binary_operator: '||'| '*' | '/' | '%' | '+' |'-'| '<<' | '>>' | '&' | '|' | '<' | '<=' | '>' | '>=' | '=' |'==' | '!=' | '<>' | IS | (IS NOT) | IN | LIKE |GLOB| MATCH |REGEXP | AND |OR;
unary_operator: '-' | '+' | '~' | NOT;
function_name: WORD;
error_message: string_literal;

//bind_paramter: 


// START: tokens


NAME: QUOTE? (WORD) QUOTE?;
BEGIN_C : B E G I N;

END_C : E N D ;

TRANSACTION: T R A N S A C T I O N;

CREATE : C R E A T E;

TEMPORARY : T E M P (O R A R Y)? ;

TABLE : T A B L E;

INDEX : I N D E X;

NOT_NULL : N O T N U L L;

PRIMARY_KEY : P R I M A R Y K E Y;

FOREIGN_KEY : F O R E I G N K E Y;

CHECK_C : C H E C K;

DEFAULT : D E F A U L T;

TRIGGER : T R I G G E R;

VIEW : V I E W;

SELECT : S E L E C T;

DROP : D R O P;
ON : O N;

AS : A S;

WHEN : W H E N;
DEFERRED: D E F E R R E D;
DEFERRABLE: D E F E R R A B L E;

REFERENCES : R E F E R E N C E S;

CONSTRAINT : C O N S T R A I N T ;

AUTOINCREMENT : A U T O I N C R E M E N T;
DELETE: D E L E T E;
SET: S E T;
CASCADE: C A S C A D E;
RESTRICT: R E S T R I C T;
NO: N O;
ACTION: A C T I O N;
CONFLICT: C O N F L I C T;
ROLLBACK: R O L L B A C K;
ABORT: A B O R T;
FAIL: F A I L;
IGNORE: I G N O R E;
REPLACE: R E P L A C E;
FOR: F O R;
EACH: E A C H;
ROW: R O W;
BEFORE: B E F O R E;
AFTER: A F T E R;
NOT: N O T;
WITHOUT: W I T H O U T;
ROWID: R O W I D;
COLLATE: C O L L A T E;
INITIALLY: I N I T I A L L Y;
IMMEDIATE: I M M E D I A T E;

UNIQUE : 'unique';

SEMICOLON : ';';
WORD : ('a'..'z' | 'A'..'Z' | DIGIT | '_')+;

IF : I F;
EXISTS: E X I S T S;

DIGIT: '0'..'9';
ANYCHAR : . ; 


QUOTE : '\''|'"';
NULL : N U L L;
CURRENT_TIMESTAMP : C U R R E N T '_' T I M E S T A M P;
CURRENT_TIME: C U R R E N T '_' T I M E;
CURRENT_DATE: C U R R E N T '_' D A T E;
COMMIT: C O M M I T;
INSERT: I N S E R T;
UPDATE: U P D A T E;
ASC: A S C;
DESC: D E S C;
INSTEAD: I N S T E A D;
OF: O F;
PRIMARY: P R I M A R Y;
FOREIGN: F O R E I G N;
KEY: K E Y;
VALUE: V A L U E;
MATCH: M A T C H;
GLOB: G L O B;
CAST: C A S T;
LIKE: L I K E;
REGEXP: R E G E X P;
ESCAPE: E S C A P E;
ISNULL: I S N U L L;
NOTNULL: N O T N U L L;
IS: I S;
BETWEEN: B E T W E E N;
AND: A N D;
IN: I N;
CASE: C A S E;
THEN: T H E N;
ELSE: E L S E;
END: E N D;
DISTINCT: D I S T I N C T;
RAISE: R A I S E;
OR: O R;
CHECK: C H E C K;



fragment A:('a'|'A');
fragment B:('b'|'B');
fragment C:('c'|'C');
fragment D:('d'|'D');
fragment E:('e'|'E');
fragment F:('f'|'F');
fragment G:('g'|'G');
fragment H:('h'|'H');
fragment I:('i'|'I');
fragment J:('j'|'J');
fragment K:('k'|'K');
fragment L:('l'|'L');
fragment M:('m'|'M');
fragment N:('n'|'N');
fragment O:('o'|'O');
fragment P:('p'|'P');
fragment Q:('q'|'Q');
fragment R:('r'|'R');
fragment S:('s'|'S');
fragment T:('t'|'T');
fragment U:('u'|'U');
fragment V:('v'|'V');
fragment W:('w'|'W');
fragment X:('x'|'X');
fragment Y:('y'|'Y');
fragment Z:('z'|'Z');

WS : (' ' | '\t' | '\r'| '\n')+ {$channel=HIDDEN;};

//END: tokens
