grammar SQLiteCreate;

options {
    language=CSharp3;
    TokenLabelType=CommonToken;
    output=AST;
    ASTLabelType=CommonTree;
}

@lexer::namespace{SQLiteParser}
@parser::namespace{SQLiteParser}


//START: rules



create_table : CREATE TEMPORARY? TABLE (IF NOT EXISTS)? table_name '(' column_def (COMMA column_def)* RP (table-constraint (COMMA table-constraint)?)?  (WITHOUT ROWID)? SEMICOLON;



statement : begin_transaction
    | commit
    | drop
//    | comment
    | create
    | EOF;

begin_transaction : BEGIN_C TRANSACTION? SEMICOLON;

commit : COMMIT SEMICOLON;

drop : DROP (tbl_drop | view_drop | trg_drop) SEMICOLON;

tbl_drop: TABLE COMMIT table_name;

view_drop: VIEW if_exists? view_name;

trg_drop: TRIGGER if_exists? trigger_name;


table_name : qualified_name;

qualified_name : WORD ('.' WORD)?;


if_exists : IF EXISTS;





create : CREATE TEMPORARY? UNIQUE? INDEX NAME ON table_name parens_field_list conflict_clause? SEMICOLON
         
         

    | CREATE TEMPORARY? TABLE table_name '(' definition (COMMA definition)* RP SEMICOLON
 
    |CREATE TEMPORARY? TRIGGER NAME before_or_after? database_event ON table_name trigger_action SEMICOLON


    | CREATE TEMPORARY? TRIGGER NAME instead_of database_event ON view_name trigger_action
| CREATE TEMPORARY? VIEW view_name AS select_statement;
    
    
definition : constraint_def | column_def;

//comment*
column_def:  NAME type? column_constraint_def*;

type : WORD parens_value_list?;

column_constraint_def : (CONSTRAINT constraint_name)? column_constraint
    {
        $return = {
            name => $item[2],
            %{ $item[3] },
        }
    }
    |
    column_constraint;

column_constraint : NOT_NULL conflict_clause?
    {
        $return = {
            type => 'not_null',
        }
    }
    |
    PRIMARY_KEY sort_order? conflict_clause?
    {
        $return = {
            type        => 'primary_key',
            sort_order  => $item[2][0],
            on_conflict => $item[2][0],
        }
    }
    |
    UNIQUE conflict_clause?
    {
        $return = {
            type        => 'unique',
            on_conflict => $item[2][0],
        }
    }
    |
    CHECK_C '(' expr RP conflict_clause?
    {
        $return = {
            type        => 'check',
            expression  => $item[3],
            on_conflict => $item[5][0],
        }
    }
    |
    DEFAULT VALUE
    {
        $return   = {
            type  => 'default',
            value => $item[2],
        }
    }
    |
    REFERENCES ref_def cascade_def?
    {
        $return   = {
            type             => 'foreign_key',
            reference_table  => $item[2]{'reference_table'},
            reference_fields => $item[2]{'reference_fields'},
            on_delete        => $item[3][0]{'on_delete'},
            on_update        => $item[3][0]{'on_update'},
        }
    }
    |
    AUTOINCREMENT
    {
        $return = {
            type => 'autoincrement',
        }
    };
	//comment*
constraint_def :  CONSTRAINT constraint_name table_constraint
    {
        $return = {
            comments => $item[1],
            name => $item[3],
            %{ $item[4] },
        }
    }
    |
	//comment*
     table_constraint
    {
        $return = {
            comments => $item[1],
            %{ $item[2] },
        }
    };

table_constraint : PRIMARY_KEY parens_field_list conflict_clause?
    {
        $return         = {
            supertype   => 'constraint',
            type        => 'primary_key',
            fields      => $item[2],
            on_conflict => $item[3][0],
        }
    }
    |
    UNIQUE parens_field_list conflict_clause?
    {
        $return         = {
            supertype   => 'constraint',
            type        => 'unique',
            fields      => $item[2],
            on_conflict => $item[3][0],
        }
    }
    |
    CHECK_C '(' expr RP conflict_clause?
    {
        $return         = {
            supertype   => 'constraint',
            type        => 'check',
            expression  => $item[3],
            on_conflict => $item[5][0],
        }
    }
    |
    FOREIGN_KEY parens_field_list REFERENCES ref_def cascade_def?;


	ref_def : table_name parens_field_list;

cascade_def : cascade_update_def cascade_delete_def?
    { $return = {  on_update => $item[1], on_delete => $item[2][0] } }
    |
    cascade_delete_def cascade_update_def?
    { $return = {  on_delete => $item[1], on_update => $item[2][0] } };

cascade_delete_def : ON DELETE (SET NULL|SET DEFAULT|CASCADE|RESTRICT|NO ACTION)
    { $return = $1};

cascade_update_def : ON UPDATE (SET NULL|SET DEFAULT|CASCADE|RESTRICT|NO ACTION)
    { $return = $1};



qualified_name : NAME |

 (WORD+)'.' (WORD+)
    { $return = { db_name => $1, name => $2 } };

field_name : NAME;

constraint_name : NAME;

conflict_clause : ON CONFLICT conflict_algorigthm;

conflict_algorigthm : (ROLLBACK|ABORT|FAIL|IGNORE|REPLACE);

parens_field_list : '(' column_list RP
    { $item[2] };

column_list : field_name (COMMA field_name)*;

parens_value_list : '(' VALUE (COMMA VALUE)* RP;

expr : ('^'|RP)+;

sort_order : (ASC|DESC);

database_event : (DELETE|INSERT|UPDATE) 
| UPDATE OF column_list;

trigger_action : for_each? when? BEGIN_C trigger_step+ END_C;

for_each : FOR EACH ROW;

when : WHEN expr { $item[2] };

statement_body : string | nonstring;

trigger_step : (SELECT|DELETE|INSERT|UPDATE) statement_body+ SEMICOLON
    {
        $return = join( ' ', $item[1], join ' ', @{ $item[2] || [] } )
    };

before_or_after : (BEFORE|AFTER) { $return = lc $1 };

instead_of: INSTEAD OF;



view_name : qualified_name;

trigger_name : qualified_name;

select_statement : SELECT ('^'|';')+ SEMICOLON
    {
        $return = join( ' ', $item[1], $item[2] );
    };


string :
'\'' ('.' |''| ('^' |'\'| '\''))* '\'';
   
nonstring : ('^' | ';' | '\''| '"')+;

//END: rules





  

// START: tokens

VALUE : ('-'|'+')? '.'? DIGIT+ (('e'|'E')DIGIT+)?
        
          {  }

    | '\'' ANYCHAR? '\''

    | NULL
  
    | CURRENT_TIMESTAMP
   
  ;


NAME: QUOTE? (WORD) QUOTE?;
BEGIN_C : B E G I N;

END_C : E N D ;

TRANSACTION: T R A N S A C T I O N;

CREATE : C R E A T E;

TEMPORARY : T E M P (O R A R Y)? ;

TABLE : T A B L E;

INDEX : I N D E X;

NOT_NULL : N O T N U L L;

PRIMARY_KEY : P R I M A R Y K E Y;

FOREIGN_KEY : F O R E I G N K E Y;

CHECK_C : C H E C K;

DEFAULT : D E F A U L T;

TRIGGER : T R I G G E R;

VIEW : V I E W;

SELECT : S E L E C T;

DROP : D R O P;
ON : O N;

AS : A S;

WHEN : W H E N;

REFERENCES : R E F E R E N C E S;

CONSTRAINT : C O N S T R A I N T ;

AUTOINCREMENT : A U T O I N C R E M E N T;
DELETE: D E L E T E;
SET: S E T;
CASCADE: C A S C A D E;
RESTRICT: R E S T R I C T;
NO: N O;
ACTION: A C T I O N;
CONFLICT: C O N F L I C T;
ROLLBACK: R O L L B A C K;
ABORT: A B O R T;
FAIL: F A I L;
IGNORE: I G N O R E;
REPLACE: R E P L A C E;
FOR: F O R;
EACH: E A C H;
ROW: R O W;
BEFORE: B E F O R E;
AFTER: A F T E R;

UNIQUE : 'unique';

SEMICOLON : ';';
WORD : ('a'..'z' | 'A'..'Z' | DIGIT | '_')+;

IF : I F;
EXISTS: E X I S T S;

DIGIT: '0'..'9';
ANYCHAR : . ; 


QUOTE : '\''|'"';
NULL : N U L L;
CURRENT_TIMESTAMP : C U R R E N T '_' T I M E S T A M P;
COMMIT: C O M M I T;
INSERT: I N S E R T;
UPDATE: U P D A T E;
ASC: A S C;
DESC: D E S C;
INSTEAD: I N S T E A D;
OF: O F;


fragment A:('a'|'A');
fragment B:('b'|'B');
fragment C:('c'|'C');
fragment D:('d'|'D');
fragment E:('e'|'E');
fragment F:('f'|'F');
fragment G:('g'|'G');
fragment H:('h'|'H');
fragment I:('i'|'I');
fragment J:('j'|'J');
fragment K:('k'|'K');
fragment L:('l'|'L');
fragment M:('m'|'M');
fragment N:('n'|'N');
fragment O:('o'|'O');
fragment P:('p'|'P');
fragment Q:('q'|'Q');
fragment R:('r'|'R');
fragment S:('s'|'S');
fragment T:('t'|'T');
fragment U:('u'|'U');
fragment V:('v'|'V');
fragment W:('w'|'W');
fragment X:('x'|'X');
fragment Y:('y'|'Y');
fragment Z:('z'|'Z');

WS : (' ' | '\t' | '\r'| '\n')+ {$channel=HIDDEN;};

//END: tokens